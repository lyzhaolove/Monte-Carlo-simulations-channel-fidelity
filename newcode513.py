import random
# [[5,1,3]]码纠正任意一个位置的任意三种错误算子，其元素个数为16
T = [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0, 1]]
# S为稳定子群，它包括由单位元及4个生成元生成的集合，其元素个数为16
S = [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 1, 0, 0, 1, 1, 0, 0], [0, 1, 0, 0, 1, 0, 0, 1, 1, 0],
     [1, 0, 1, 0, 0, 0, 0, 0, 1, 1], [0, 1, 0, 1, 0, 1, 0, 0, 0, 1], [1, 1, 0, 1, 1, 0, 1, 0, 1, 0],
     [0, 0, 1, 1, 0, 0, 1, 1, 1, 1], [1, 1, 0, 0, 0, 1, 1, 1, 0, 1], [1, 1, 1, 0, 1, 0, 0, 1, 0, 1],
     [0, 0, 0, 1, 1, 1, 0, 1, 1, 1], [1, 1, 1, 1, 0, 1, 0, 0, 1, 0], [0, 1, 1, 1, 1, 0, 1, 0, 0, 1],
     [1, 0, 0, 0, 1, 1, 1, 0, 1, 1], [1, 0, 1, 1, 1, 1, 0, 1, 0, 0], [0, 1, 1, 0, 0, 1, 1, 1, 1, 0],
     [0, 0, 1, 0, 1, 1, 1, 0, 0, 0]]

# 定义E为空集合，再向里面添加T*S中的元素
E = []
for i in range(16):
    for j in range(16):
        e = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        for t in range(10):
            e[t] = T[i][t] ^ S[j][t]
        E.append(e)
print("E=", E)


# 循环20次，rate代表去极化率，去极化率变化20次
for q in range(21):
    rate = 0.01
    rate *= q
    count = 0
    num = 0
# print("rate=", rate)
    for k in range(1000):  # 模拟1000次，每次循环将错误算子D初始化为I
        D = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        r = random.random()
        s = random.random()
        t = random.random()
        m = random.random()
        n = random.random()   # r,s,t,m,n分别表示五个量子比特上独立出错的情况
        if r < rate:
            r = int(4 * r / rate)
            if r & 1 == 0 and r >> 1 == 0:
                D[0] = 0
                D[5] = 0
            elif r & 1 == 1 and r >> 1 == 0:
                D[0] = 1
                D[5] = 0
            elif r & 1 == 0 and r >> 1 == 1:
                D[0] = 0
                D[5] = 1
            elif r & 1 == 1 and r >> 1 == 1:
                D[0] = 1
                D[5] = 1
        if s < rate:
            s = int(4 * s / rate)
            if s & 1 == 0 and s >> 1 == 0:
                D[1] = 0
                D[6] = 0
            elif s & 1 == 1 and s >> 1 == 0:
                D[1] = 1
                D[6] = 0
            elif s & 1 == 0 and s >> 1 == 1:
                D[1] = 0
                D[6] = 1
            elif s & 1 == 1 and s >> 1 == 1:
                D[1] = 1
                D[6] = 1
        if t < rate:
            t = int(4 * t / rate)
            if t & 1 == 0 and t >> 1 == 0:
                D[2] = 0
                D[7] = 0
            elif t & 1 == 1 and t >> 1 == 0:
                D[2] = 1
                D[7] = 0
            elif t & 1 == 0 and t >> 1 == 1:
                D[2] = 0
                D[7] = 1
            elif t & 1 == 1 and t >> 1 == 1:
                D[2] = 1
                D[7] = 1
        if m < rate:
            m = int(4 * m / rate)
            if m & 1 == 0 and m >> 1 == 0:
                D[3] = 0
                D[8] = 0
            elif m & 1 == 1 and m >> 1 == 0:
                D[3] = 1
                D[8] = 0
            elif m & 1 == 0 and m >> 1 == 1:
                D[3] = 0
                D[8] = 1
            elif m & 1 == 1 and m >> 1 == 1:
                D[3] = 1
                D[8] = 1
        if n < rate:
            n = int(4 * n / rate)
            if n & 1 == 0 and n >> 1 == 0:
                D[4] = 0
                D[9] = 0
            elif n & 1 == 1 and n >> 1 == 0:
                D[4] = 1
                D[9] = 0
            elif n & 1 == 0 and n >> 1 == 1:
                D[4] = 0
                D[9] = 1
            elif n & 1 == 1 and n >> 1 == 1:
                D[4] = 1
                D[9] = 1
            # print("rate=",rate)

        if D in E:  # 判断错误算子是否能被纠正，
            count += 1
    probability = count / 1000
    print(probability, end=', ')
    # print("num=", num)
